<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>project1</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">




<section id="project-1" class="level1">
<h1>Project 1</h1>
<section id="overall-goal" class="level2">
<h2 class="anchored" data-anchor-id="overall-goal">Overall Goal</h2>
<p>Our goal is to write functions that will manipulate and process data sets that come in a certain form. You’ll then create fit some basic linear regression models and implement a cross-validation algorithm to judge the models.</p>
<p>This project is meant to assess your ability to program in python. You’ll write up your project in a google colab notebook. A link to the notebook should be submitted in the assignment link - please update your sharing settings so we can view the file. The result should be a report with a narrative throughout, section headings, graphs outputted in appropriate places, etc. To be clear <strong>be sure to include markdown text describing what you are doing and your thought process (not just the question prompts), even when not explicitly asked for!</strong> The audience you are writing for is someone that understands programming and very basic statistics, but would need you to provide details and explanation of what you are doing to understand it.</p>
<p><strong>Both partners should submit the link.</strong></p>
</section>
<section id="data" class="level2">
<h2 class="anchored" data-anchor-id="data">Data</h2>
<p>We’ll use a number of <code>.csv</code> files that contain information from the census bureau surveys. This data is a little older (2010 is the newest data). Our first goal will be to read in one of these <code>.csv</code> files and parse the data using functions we’ve written. Then we’ll combine some parsed data and deal with it from there.</p>
</section>
<section id="part-1-data-processing" class="level2">
<h2 class="anchored" data-anchor-id="part-1-data-processing">Part 1: Data Processing</h2>
<section id="first-steps" class="level3">
<h3 class="anchored" data-anchor-id="first-steps">First Steps</h3>
<p>First I’ll just explain what you’ll do to parse the data you read in. Then I’ll give you requirements on how to parse it afterward. (I find it easier to first do all of the things below without writing functions first. Then convert your code into the required functions.) You only need to include your final work/functions with narrative in your submitted document.</p>
<p>Read in the data set available here: <a href="https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv" class="uri">https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv</a></p>
<p>Now the format of the data is kind of weird. There is a column for <code>Area_name</code> (US, NC, or a county), a column called <code>STCOU</code>, and then four columns corresponding to each question on the survey. This survey was about school enrollment. Let’s process this data!</p>
<ol type="1">
<li><p>Select only the following columns:</p>
<ul>
<li><code>Area_name</code></li>
<li><code>STCOU</code></li>
<li>Any column that ends in “D”</li>
<li>To do the above, use the <code>.loc[]</code> method. Note that the <code>.str.endswith()</code> method can be used on the column names for the columns that end with “D”.</li>
</ul></li>
<li><p>The data you’ll have is in <strong>wide</strong> format. That is, there are multiple observations in a given row (each column that ends in “D” corresponds to a particular year’s measurement). We want to convert the data into <strong>long</strong> format where each row has only one enrollment value for that <code>Area_name</code>. Do this operation using the <code>pd.melt()</code> function (<a href="https://pandas.pydata.org/docs/user_guide/reshaping.html#reshaping-melt">info here</a>).</p></li>
<li><p>One of the new columns should now correspond to the old column names that ended with a “D”. (All columns in these census data files will have this similar format - For more about the variables see <a href="https://www4.stat.ncsu.edu/~online/datasets/Mastdata.xls">the data information sheet</a>)<br>
The first three characters of the former column names represent the survey and the next four characters represent the type of value you have from that survey. The last two characters prior to the “D” represent the year of the measurement. For this part:</p>
<ul>
<li>Create a loop that loops over the rows of the data frame</li>
<li>At each iteration,
<ul>
<li>parse the string from your new column in order to pull out the year and convert it into a <strong>numeric</strong> value such as <code>1997</code> or <code>2002.</code> Add this new <code>year</code> variable to your data frame. Note: the data set above only has data from the 1900’s but the next data set we read in has data from the 2000’s. Handle that appropriately!</li>
<li>grab the first three characters and following four digits to create a new variable representing which measurement was grabbed. Add this new <code>measurement</code> variable to your data frame as well.</li>
</ul></li>
<li>Drop the original column name variable.</li>
</ul></li>
<li><p>Split the data frame into two data frames:</p>
<ul>
<li>one data frame should contain only non-county data</li>
<li>the other should contain only county level data</li>
</ul>
<p>Note that all county measurements have the format “County Name, DD” where “DD” represents the state. Use the <code>.apply()</code> method with a <code>lambda</code> function to create an indexing vector you use to do the subsetting. <code>np.logical_not()</code> comes in handy!</p></li>
<li><p>For the county level data frame, create a new variable that describes which state one of these county measurements corresponds to (the two digit abbreviation is fine!).</p></li>
<li><p>For the non-county level data frame, create a new variable called <code>division</code> corresponding to the state’s classification of division <a href="https://en.wikipedia.org/wiki/List_of_regions_of_the_United_States">here</a> (the Census Bureau-designated regions and divisions). If the row corresponds to a non-state (i.e.&nbsp;<code>UNITED STATES</code>), return <code>ERROR</code> for the division. The code for this part will not be a ton of fun to write! Write a function with basic <code>if/elif</code> for a single value of <code>Area_name</code>. Then, use <code>np.vectorize()</code> to make it work for a full vector of values.</p></li>
</ol>
</section>
<section id="requirements" class="level3">
<h3 class="anchored" data-anchor-id="requirements">Requirements</h3>
<p>Now we want to repeat the above process for the 2nd component of the data set. This is available at the link below.</p>
<ul>
<li><a href="https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv" class="uri">https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv</a></li>
</ul>
<p>Rather than copying and pasting a bunch of stuff and changing things here and there, we want to write functions that do the above pieces and one function that we can call to do it all!</p>
<ul>
<li>Write one function that takes care of steps 1 &amp; 2 above. Give an optional argument (that is it has a default value) that allows the user to specify the name of the column representing the value (‘enrollment’ for these two data sets).</li>
<li>Write another function that takes in the output of step 2 and does step 3 above.</li>
<li>Write a function to do step 5</li>
<li>Write a function to do step 6</li>
<li>Write another function that takes in the output from step 3 and creates the two data frames in step 4, calls the above two functions (to perform steps 5 and 6), and returns two final data frames</li>
</ul>
<p>Now last thing, put it all into one function call! This is called creating a <a href="https://en.wikipedia.org/wiki/Wrapper_function#:~:text=A%20wrapper%20function%20is%20a,little%20or%20no%20additional%20computation.">wrapper</a> function. Create a function that takes in the URL of a <code>.csv</code> file in this format and the optional argument for the variable name, calls the functions you wrote above, and then returns the two data frames in a list.</p>
</section>
<section id="call-it-and-combine-your-data" class="level3">
<h3 class="anchored" data-anchor-id="call-it-and-combine-your-data">Call It and Combine Your Data</h3>
<p>Call the function you made two times to read in and parse the two <code>.csv</code> files mentioned so far. Be sure to call the new <code>value</code> column the same in both function calls.</p>
<p>Now we want to join the two county level data sets and the two state level data sets. Write a function that takes in unlimited positional arguments. When you call the function these arguments will be the results of calls to your wrapper function (so each argument will be a list with the two data sets in it).</p>
<ul>
<li>Within the function itself, use <code>map()</code> and a <code>lambda</code> function to obtain just the county level data for every argument. Then use the <code>reduce()</code> function from the <code>functools</code> module with a <code>lambda</code> function that calls <code>pd.concat()</code>.</li>
<li>Repeat for the non county level data.</li>
<li>Put the two combined data sets into a list and return it (so it will have the same format as the inputs!</li>
</ul>
<p>Call this function to combine the two data objects into one object (that has two data frames: the combined county level data and the combined non-county level data).</p>
<p>Note: Here is what the combined data should look like.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[            Area_name  STCOU  enrollment    year measurement state
2         Autauga, AL   1001        6829  1987.0     EDU0101    AL
3         Baldwin, AL   1003       16417  1987.0     EDU0101    AL
4         Barbour, AL   1005        5071  1987.0     EDU0101    AL
5            Bibb, AL   1007        3557  1987.0     EDU0101    AL
6          Blount, AL   1009        7319  1987.0     EDU0101    AL
...               ...    ...         ...     ...         ...   ...
31975  Sweetwater, WY  56037        6964  2006.0     EDU0152    WY
31976       Teton, WY  56039        2264  2006.0     EDU0152    WY
31977       Uinta, WY  56041        4298  2006.0     EDU0152    WY
31978    Washakie, WY  56043        1410  2006.0     EDU0152    WY
31979      Weston, WY  56045        1076  2006.0     EDU0152    WY

[62900 rows x 6 columns],            Area_name  STCOU  enrollment    year measurement    division
0      UNITED STATES      0    40024299  1987.0     EDU0101       ERROR
1            ALABAMA   1000      733735  1987.0     EDU0101  Division 6
69            ALASKA   2000      102872  1987.0     EDU0101  Division 9
99           ARIZONA   4000      609411  1987.0     EDU0101  Division 8
115         ARKANSAS   5000      429260  1987.0     EDU0101  Division 7
...              ...    ...         ...     ...         ...         ...
31650       VIRGINIA  51000     1220440  2006.0     EDU0152  Division 5
31787     WASHINGTON  53000     1026774  2006.0     EDU0152  Division 9
31827  WEST VIRGINIA  54000      281938  2006.0     EDU0152  Division 5
31883      WISCONSIN  55000      876700  2006.0     EDU0152  Division 3
31956        WYOMING  56000       85193  2006.0     EDU0152  Division 8

[1060 rows x 6 columns]]</code></pre>
</div>
</div>
</section>
</section>
<section id="double-check-it-generalizes" class="level2">
<h2 class="anchored" data-anchor-id="double-check-it-generalizes">Double Check It Generalizes!</h2>
<p>Read in another similar data set and apply our functions!</p>
<ul>
<li>Run your data processing and combination functions on the four data sets at URLs given below:
<ul>
<li>https://www4.stat.ncsu.edu/~online/datasets/PST01a.csv</li>
<li>https://www4.stat.ncsu.edu/~online/datasets/PST01b.csv</li>
<li>https://www4.stat.ncsu.edu/~online/datasets/PST01c.csv</li>
<li>https://www4.stat.ncsu.edu/~online/datasets/PST01d.csv</li>
</ul></li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[            Area_name  STCOU  default    year measurement state
2         Autauga, AL   1001    25508  1971.0     PST0151    AL
3         Baldwin, AL   1003    60141  1971.0     PST0151    AL
4         Barbour, AL   1005    23092  1971.0     PST0151    AL
5            Bibb, AL   1007    13919  1971.0     PST0151    AL
6          Blount, AL   1009    27817  1971.0     PST0151    AL
...               ...    ...      ...     ...         ...   ...
31975  Sweetwater, WY  56037    41226  2009.0     PST0452    WY
31976       Teton, WY  56039    20710  2009.0     PST0452    WY
31977       Uinta, WY  56041    20927  2009.0     PST0452    WY
31978    Washakie, WY  56043     7911  2009.0     PST0452    WY
31979      Weston, WY  56045     7009  2009.0     PST0452    WY

[125800 rows x 6 columns],            Area_name  STCOU    default    year measurement    division
0      UNITED STATES      0  206827028  1971.0     PST0151       ERROR
1            ALABAMA   1000    3497452  1971.0     PST0151  Division 6
69            ALASKA   2000     316494  1971.0     PST0151  Division 9
99           ARIZONA   4000    1896108  1971.0     PST0151  Division 8
115         ARKANSAS   5000    1972028  1971.0     PST0151  Division 7
...              ...    ...        ...     ...         ...         ...
31650       VIRGINIA  51000    7882590  2009.0     PST0452  Division 5
31787     WASHINGTON  53000    6664195  2009.0     PST0452  Division 9
31827  WEST VIRGINIA  54000    1819777  2009.0     PST0452  Division 5
31883      WISCONSIN  55000    5654774  2009.0     PST0452  Division 3
31956        WYOMING  56000     544270  2009.0     PST0452  Division 8

[2120 rows x 6 columns]]</code></pre>
</div>
</div>
</section>
<section id="cross-validation" class="level2">
<h2 class="anchored" data-anchor-id="cross-validation">Cross-Validation</h2>
<p>For the last part of the project we’ll fit two linear regression models and judge them using cross-validation (no training/test split, we’ll just use CV). However, we won’t be able to use standard cross-validation. We’ll write our own function to do it!</p>
<section id="subset-of-data" class="level3">
<h3 class="anchored" data-anchor-id="subset-of-data">Subset of Data</h3>
<p>Use the <code>enrollment</code> data sets from earlier.</p>
<ul>
<li>Subset the list object so that we’re only looking at the non county level data.</li>
<li>Remove any rows where the division variable is <code>ERROR</code> and select only the <code>year</code>, <code>division</code>, and <code>enrollment</code> variables (or whatever you called the last one!).</li>
</ul>
</section>
<section id="two-models-under-consideration" class="level3">
<h3 class="anchored" data-anchor-id="two-models-under-consideration">Two Models Under Consideration</h3>
<p>Well use two competing models:</p>
<ul>
<li>A SLR model using <code>year</code> to predict <code>enrollment</code></li>
<li>An MLR model using <code>year</code> and <code>division</code> to predict <code>enrollment</code></li>
</ul>
<p>You’ll need to create dummy variables for the <code>division</code> variable as we did in the notes and add them to the data frame. When adding these columns to the data frame, you shouldn’t keep all 9 variables (recall the last column is redundant given all the others). Be sure to leave one of the indicator columns off!</p>
<p>If you’d like, feel free to fit the two models to the data here (this doesn’t need to go in the final report).</p>
</section>
<section id="cross-validation-1" class="level3">
<h3 class="anchored" data-anchor-id="cross-validation-1">Cross-Validation</h3>
<p>We want to see how well these two competing models do at predicting. However, we can’t use the usual cross-validation because our data is over time (<code>year</code>).</p>
<p>Instead, what we want to do is train the model/judge it sequentially.</p>
<ol type="1">
<li>Use the first three years of data to fit the model. Use that model to predict the fourth year. Calculate the MSE for those predictions.</li>
<li>Use the first four years of data to fit the model. Use that model to predict the fifth year. Calculate the MSE for those predictions.</li>
<li>Repeat until you predict for the last year.</li>
<li>Sum up the MSE values to get an overall MSE for the model!</li>
</ol>
<p>Write a function to do the above given a particular <code>X</code>, <code>y</code>, and starting <code>year</code>.</p>
<p>Some guidelines and helpful hints:</p>
<ul>
<li>First write a function to get the MSE for one step of the above only (don’t worry about combining things yet).
<ul>
<li>Have this function take in a data frame of predictors <code>X</code> (this will be used in the <code>.fit()</code> method of a <code>LinearRegression()</code> object), a 1D response <code>y</code>, and a <code>last_year</code> argument.</li>
<li>Use the <code>last_year</code> argument to subset the data into a training <code>X</code> and <code>y</code> and a testing <code>X</code> and <code>y</code>. Have your training set include all years up to and including <code>last_year</code> and your test set just include the year <code>last_year</code> + 1.<br>
</li>
<li>Do the model fitting and predictions. Return the mean squared error</li>
</ul></li>
<li>That will act as a helper function for our function that find the CV error.</li>
<li>Now write a function to obtain the CV value over all the years (other than the initial training block)
<ul>
<li>Have this function take in <code>X</code>, <code>y</code> (both as above), and a <code>first_year</code> argument.</li>
<li>If the <code>first_year</code> is less than 1989, have the function raise an error and return a message</li>
<li>Initialize an MSE value at 0</li>
<li>If the not, use a loop from <code>first_year</code> to the last year in the data set (find that value programmatically)
<ul>
<li>Within the loop, use your previous function and augmented assignment to add the MSE for the given year</li>
</ul></li>
<li>Return the MSE</li>
</ul></li>
</ul>
<p>Now run your function using the SLR model. Repeat using the MLR model. Discuss the MSE values you see.</p>
<p>That’s everything. Check the rubric on the next page to make sure you are comfortable with your submission. Good luck! Have fun!</p>
<div style="page-break-after: always;"></div>
</section>
</section>
</section>
<section id="rubric-for-grading-total-100-points" class="level1">
<h1>Rubric for Grading (total = 100 points)</h1>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Item</th>
<th>Points</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Introduction to purpose of report</td>
<td>5</td>
<td>Worth either 0, 2, or 5</td>
</tr>
<tr class="even">
<td>Data Processing Functions</td>
<td>45</td>
<td>Worth either 0, 5, 10, …, 45</td>
</tr>
<tr class="odd">
<td>Combining Data Function</td>
<td>15</td>
<td>Worth either 0, 3, 5, …, 15</td>
</tr>
<tr class="even">
<td>Cross Validation Functions</td>
<td>35</td>
<td>Worth either 0, 3, 5, …, 35</td>
</tr>
</tbody>
</table>
<p>Notes on grading:</p>
<ul>
<li><p>For each item in the rubric, your grade will be lowered one level for each each error (syntax, logical, or other) in the code and for each required item that is missing or lacking a description.</p></li>
<li><p><strong>You should use Good Programming Practices when coding (see wolfware). If you do not follow GPP you can lose up to 30 points on the project.</strong></p></li>
</ul>
<p>The reports should include a narrative throughout, section headings, graphs outputted in appropriate places, etc. To be clear <strong>be sure to include markdown text describing what you are doing, even when not explicitly asked for!</strong> Points will be deducted from appropriate sections as appropriate.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>